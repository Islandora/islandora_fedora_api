<?php
/**
 * @file
 * Lowest-level wrappers for Fedora Commons's REST API functions.
 * Functions return the HTTP response directly.
 *
 * All of these functions look at the response code of the error and
 * throw FedoraAPIRestException if the response code isn't success (2XX).
 *
 * Much documentation about the API that is wraps can be found here:
 * https://wiki.duraspace.org/display/FCR30/REST+API
 */

/**
 * A low level wrapper on fedora APIA functions
 */
class FedoraAPIA {

  /**
   * The FedoraConnection object for this FedoraAPI.
   *
   * @var FedoraConnection
   */
  public $connection;

  /**
   * Constructor for a new FedoraAPI object.
   *
   * @param FedoraConnection $connection
   *   (optional) a new one will be created if not supplied.
   */
  function __construct($connection = NULL) {
    if ($connection != NULL) {
      $this->connection = $connection;
    }
    else {
      // Construct a connection from Drupal's API settings.
      module_load_include('connection.inc', 'islandora_fedora_api');
      $this->connection = new FedoraConnection();
    }
  }

  /**
   * Query fedora to return a list of objects.
   *
   * @param string $terms
   *   (optional) A phrase represented as a sequence of characters (including the ? and * wildcards) for the search.
   *   If this sequence is found in any of the fields for an object, the object is considered a match. Do NOT use
   *   this parameter in combination with the "query" parameter.
   * @param string $query
   *   (optional) A sequence of space-separated conditions. A condition consists of a metadata element name followed
   *   directly by an operator, followed directly by a value. Valid element names are (pid, label, state, ownerId,
   *   cDate, mDate, dcmDate, title, creator, subject, description, publisher, contributor, date, type, format,
   *   identifier, source, language, relation, coverage, rights). Valid operators are: contains (), equals (=),
   *   greater than (>), less than (<), greater than or equals (>=), less than or equals (<=). The contains () operator
   *   may be used in combination with the ? and * wildcards to query for simple string patterns. Space-separators
   *   should be encoded in the URL as %20. Operators must be encoded when used in the URL syntax as follows: the (=)
   *   operator must be encoded as %3D, the (>) operator as %3E, the (<) operator as %3C, the (>=) operator
   *   as %3E%3D, the (<=) operator as %3C%3D, and the (~) operator as %7E. Values may be any string. If the string
   *   contains a space, the value should begin and end with a single quote character ('). If all conditions are met
   *   for an object, the object is considered a match. Do NOT use this parameter in combination with the
   *   "terms" parameter.
   * @param string,int $maxResults
   *   (optional) Default: 25. The maximum number of results that the server should provide at once.
   * @param string $resultFormat
   *   (optional) Default: XML. The preferred output format. Options: HTML, XML.
   * @param array $displayFields
   *   (optional) Default: array('pid', 'title'). The fields to be returned.
   *
   * @throws FedoraAPIRestException
   *
   * @return StdClass HTTP Response object. 'data' has XML set of results
   * @code
   *   <?xml version="1.0" encoding="UTF-8"?>
   *   <result xmlns="http://www.fedora.info/definitions/1/0/types/">
   *     <resultList>
   *     <objectFields>
   *       <pid>islandora:collectionCModel</pid>
   *       <title>Islandora Collection Content Model</title>
   *     </objectFields>
   *     <objectFields>
   *       <pid>islandora:strict_pdf</pid>
   *       <title>Strict PDF</title>
   *     </objectFields>
   *     </resultList>
   *   </result>
   * @endcode
   */
  public function findObjects($terms = '', $query = '', $maxResults = '',
    $resultFormat = 'xml', $displayFields = array('pid', 'title')
  ) {
    $fedora_url = $this->connection->requestURL();
    $request = "$fedora_url/objects?";

    if (!empty($terms)) {
      $request .= "terms=" . drupal_urlencode($terms);
    }
    elseif (!empty($query)) {
      $request .= "query=" . drupal_urlencode($query);
    }

    $request .= "&resultFormat=$resultFormat";

    foreach ($displayFields as $displayField) {
      $request .= "&$displayField=true";
    }
    $response = drupal_http_request($request);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Get the default dissemination of a datastream. (Get the contents of the datastream.)
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $dsID
   *   Datastream identifier.
   * @param String $asOfDateTime
   *   (optional) Default: NULL. Indicates that the result should be relative to the digital object as it existed
   *   at the given date and time.
   * @param String $download
   *   (optional) Default: FALSE. If true, a content-disposition header value "attachment" will be included in the
   *   response, prompting the user to save the datastream as a file.  A content-disposition header value "inline"
   *   will be used otherwise.  The filename used in the header is generated by examining in order: RELS-INT for the
   *   relationship fedora-model:downloadFilename, the datastream label, and the datastream ID.  The file extension
   *   (apart from where the filename is specified in RELS-INT) is determined from the MIMETYPE.  The order in which
   *   these filename sources are searched, and whether or not to generate an extension from the MIMETYPE, is
   *   configured in fedora.fcfg.  The file used to map between MIMETYPEs and extensions is mime-to-extensions.xml
   *   located in the server config directory.
   *
   * @return StdClass HTTP Response object. The direct response from fedora.
   */
  public function getDatastreamDissemination($pid, $dsID, $asOfDateTime = NULL, $download = NULL) {
    $pid = drupal_urlencode($pid);
    $fedora_url = $this->connection->requestURL();
    $request = "$fedora_url/objects/$pid/datastreams/$dsID/content";
    $request .= (!empty($asOfDateTime) ? "&asOfDateTime=$asOfDateTime" : '');
    if (!empty($download)) {
      $request .= (!empty($asOfDateTime) ? '&' : '?');
      $request .= "download=$download";
    }

    $response = drupal_http_request($request);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Get a datastream dissemination from Fedora.
   *
   * @param String $pid
   *   persistent identifier of the digital object
   * @param String $sdefPid
   *   persistent identifier of the sDef defining the methods
   * @param String $method
   *   method to invoke
   * @param String $methodParameters
   *   A key-value paired array of parameters required by the method
   *
   * @return StdClass HTTP response object from fedora
   */
  public function getDissemination($pid, $sdefPid, $method, $methodParameters = array()) {
    $pid = drupal_urlencode($pid);
    $sdefPid = drupal_urlencode($sdefPid);

    $fedora_url = $this->connection->requestURL();
    $request = "$fedora_url/objects/$pid/methods/$sdefPid/$method?";

    //$request .= (!empty($asOfDateTime) ? "&asOfDateTime=$asOfDateTime" : '');
    foreach ($methodParameters as $param_name => $param_value) {
      $request .= $param_name . (!empty($param_value) ? "=$param_value&" : '&');
    }

    $response = drupal_http_request($request);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Get the change history for the datastream.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $format
   *   (Optional) Default: XML. The preferred output format (xml, html).
   *
   * @return HTTP response object.
   * @code
   *   $response->data looks like:
   *   <?xml version="1.0" encoding="utf-16"?>
   *   <fedoraObjectHistory xsi:schemaLocation="http://www.fedora.info/definitions/1/0/access/
   *     http://localhost:8080/fedoraObjectHistory.xsd" pid="demo:29" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   *     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *       <objectChangeDate>2008-07-02T05:09:43.234Z</objectChangeDate>
   *   </fedoraObjectHistory>
   *  @endcode
   */
  public function getObjectHistory($pid, $format = 'xml') {
    $pid = drupal_urlencode($pid);
    $fedora_url = $this->connection->requestURL();

    $request = "$fedora_url/objects/$pid/versions?format=$format";
    $response = drupal_http_request($request);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Implements the getObjectProfile Fedora API-A method.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $format
   *   (Optional) Default: XML. The preferred output format. Options: HTML, XML.
   * @param String $asOfDateTime
   *   (Optional) Indicates that the result should be relative to the digital object as it existed on the given date.
   *   Date Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ
   *
   * @return StdClass HTTP Response object. 'data' has XML response string
   * @code
   *   <?xml version="1.0" encoding="utf-16"?>
   *   <objectProfile xsi:schemaLocation="http://www.fedora.info/definitions/1/0/access/
   *   http://localhost:8080/objectProfile.xsd" pid="islandora:demos"
   *   xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   *   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *     <objLabel>Islandora Demo Collections</objLabel>
   *     <objOwnerId>fedoraAdmin</objOwnerId>
   *     <objModels>
   *       <model>info:fedora/islandora:collectionCModel</model>
   *       <model>info:fedora/fedora-system:FedoraObject-3.0</model>
   *     </objModels>
   *     <objCreateDate>2009-03-10T07:09:53.333Z</objCreateDate>
   *     <objLastModDate>2010-03-20T23:39:58.490Z</objLastModDate>
   *     <objDissIndexViewURL>
   *         http://localhost:8080/fedora/get/islandora:demos/fedora-system:3/viewMethodIndex
   *     </objDissIndexViewURL>
   *     <objItemIndexViewURL>
   *         http://localhost:8080/fedora/get/islandora:demos/fedora-system:3/viewItemIndex
   *     </objItemIndexViewURL>
   *     <objState>A</objState>
   *   </objectProfile>
   * @endcode
   */
  public function getObjectProfile($pid, $format = 'xml', $asOfDateTime = '') {
    $pid = drupal_urlencode($pid);
    $fedora_url = $this->connection->requestURL();

    $request = "$fedora_url/objects/$pid?format=$format";
    $request .= (!empty($asOfDateTime) ? "&asOfDateTime=$asOfDateTime" : '');

    $response = drupal_http_request($request);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * List all the datastreams that are associated with this PID.
   *
   * @param <type> $pid
   *   Persistent identifier of the digital object.
   * @param <type> $format
   *   (optional) Default: XML. The preferred output format. Options: XML, HTML.
   * @param <type> $asOfDateTime
   *   (optional) Indicates that the result should be relative to the digital object as it existed on the given date.
   *   Date Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ
   *
   * @return StdClass HTTP Response object. 'data' has XML Response
   * @code
   *   <?xml version="1.0" encoding="utf-16"?>
   *   <objectDatastreams xsi:schemaLocation="http://www.fedora.info/definitions/1/0/access/
   *     http://localhost:8080/listDatastreams.xsd" pid="islandora:demos" baseURL="http://localhost:8080/fedora/"
   *     xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *     <datastream dsid="DC" label="Dublin Core Record for this object" mimeType="text/xml" />
   *     <datastream dsid="RELS-EXT" label="RDF Statements about this object" mimeType="application/rdf+xml" />
   *     <datastream dsid="COLLECTION_POLICY" label="Collection Policy" mimeType="text/xml" />
   *     <datastream dsid="TN" label="Thumbnail.png" mimeType="image/png" />
   *   </objectDatastreams>
   * @endcode
   */
  public function listDatastreams($pid, $format = 'xml', $asOfDateTime = '') {
    $pid = drupal_urlencode($pid);
    $fedora_url = $this->connection->requestURL();

    $request = "$fedora_url/objects/$pid/datastreams?format=$format";
    $request .= (!empty($asOfDateTime) ? "&asOfDateTime=$asOfDateTime" : '');
    $response = drupal_http_request($request);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Implements the listMethods Fedora API-A method.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $sdefPid
   *   (Optional) Persistent identifier of the SDef defining the methods.
   * @param String $format
   *   (Optional) Default: XML. The preferred output format. Options: XML, HTML.
   * @param String $asOfDateTime
   *   (Optional) Indicates that the result should be relative to the digital object as it existed on the given date.
   *   Date Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ
   *
   * @return StdClass HTTP Response object. 'data' has response XML.
   * @code
   *   <?xml version="1.0" encoding="utf-16"?>
   *   <objectMethods xsi:schemaLocation="http://www.fedora.info/definitions/1/0/access/
   *   http://localhost:8080/listMethods.xsd" pid="islandora:demos" baseURL="http://localhost:8080/fedora/"
   *   xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *     <sDef pid="fedora-system:3">
   *         <method name="viewObjectProfile"></method>
   *         <method name="viewMethodIndex"></method>
   *         <method name="viewItemIndex"></method>
   *         <method name="viewDublinCore"></method>
   *     </sDef>
   *   </objectMethods>
   * @endcode
   */
  public function listMethods($pid, $sdefPid = '', $format = 'xml', $asOfDateTime = '') {
    $pid = drupal_urlencode($pid);
    $fedora_url = $this->connection->requestURL();

    $request = "$fedora_url/objects/$pid/methods";
    $request .= (!empty($sdefPid) ? "/$sdefPid" : '');
    $request .= "?format=$format";
    $request .= (!empty($asOfDateTime) ? "&asOfDateTime=$asOfDateTime" : '');
    $response = drupal_http_request($request);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }
}


/**
 * A low level wrapper on fedora APIM functions
 * TODO
 *   more thorough testing of relationship functions
 */
class FedoraAPIM {
  /**
   * The FedoraConnection object for this FedoraAPIM.
   *
   * @var FedoraConnection
   */
  public $connection;

  /**
   * Constructor for a new FedoraAPIM object.
   *
   * @param FedoraConnection $connection
   *   (optional) a new one will be created if not supplied.
   */
  function __construct($connection = NULL) {
    if ($connection != NULL) {
      $this->connection = $connection;
    }
    else {
      // Construct a connection from Drupal's API settings.
      module_load_include('connection.inc', 'islandora_fedora_api');
      $this->connection = new FedoraConnection();
    }
  }


  /**
   * Add a new datastream to a fedora object. The datastreams are sent to Fedora using a multipart post if a string or
   * file is provided. Otherwise the dsLocation field is used. $file_path, $ds_string and $params['dsLocation'] are
   * all optional, however ONE and only ONE must be specified for this function.
   *
   * @param string $pid
   *   Persistent identifier of the digital object.
   * @param string $dsID
   *   Datastream identifier.
   * @param <type> $file_path
   *   (Optional)
   * @param <type> $ds_string
   *   (Optional)
   * @param <type> $params
   *   (Optional)
   *
   * @return <type>
   *
   * @todo Do more sophisticated MIME type detection. Possibly including retrieving headers of dsLocation.
   * @todo Figure out the multipart mimetype function here. I think it is buggy and should be using a dynamically
   *   generated boundry. I also think that we should be passing strings through the multipart mimetype functionalty.
   *   Much of this code was taken from here: http://drupal.org/node/270997.
   *   There is some good RFC documentation on this here:
   *     http://tools.ietf.org/html/rfc2388
   *     http://tools.ietf.org/html/rfc2046#section-5
   *     http://tools.ietf.org/html/rfc2045#page-14
   *     http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.4.2
   * @todo also sort out the commented code in this function
   */
  public function addDatastream(
    $pid, $dsID, $file_path = NULL, $ds_string = NULL,
    $params = array(
      'controlGroup' => NULL,
      'dsLocation' => NULL,
      'altIDs' => NULL,
      'dsLabel' => NULL,
      'dsState' => NULL,
      'formatURI' => NULL,
      'checksumType' => NULL,
      'checksum' => NULL,
      'mimeType' => NULL,
      'logMessage' => NULL,
    )
  ) {
    $pid = drupal_urlencode($pid);

    foreach (array('dsLabel', 'formatURI', 'logMessage') as $string_param) {
      if (key_exists($string_param, $params) && $params[$string_param] != NULL) {
        $params[$string_param] = drupal_urlencode($params[$string_param]);
      }
    }

    $request_params = NULL;

    $headers = array();

    if (!empty($params['dsLocation'])) {
      if ($params['controlGroup'] == 'X') {
        $headers['Content-Type'] = 'text/xml';
      }
      elseif (!empty($params['mimeType'])) {
        $headers['Content-Type'] = $params['mimeType'];
      }
      else {
        // TODO: More sophisticated MIME type detection. Possibly including retrieving headers of dsLocation
        $headers['Content-Type'] = 'application/x-octet-stream';
      }
    }
    elseif (!empty($file_path)) {
      // We must construct a multipart HTTP POST.
      $boundary = 'A0sFSD';
      $headers["Content-Type"] = "multipart/form-data; boundary=$boundary";
      $request_params = FedoraAPIUtils::multipartEncode($boundary, array('file' => $file_path));
    }
    elseif (!empty($ds_string)) {
      // We must construct a multipart HTTP POST.
      $boundary = 'A0sFSD';
      $headers["Content-Type"] = "text/plain";
      $request_params = $ds_string;
      //$request_params = _fedora_api_multipart_encode($boundary, array('string' => $ds_string));
    }
    else {
      return NULL;
    }

    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/datastreams/$dsID?";

    foreach ($params as $param_name => $param_value) {
      $request .= $param_value != NULL ? "$param_name=$param_value&" : '';
    }

    $response = drupal_http_request($request, $headers, 'POST', $request_params);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }


    return $response;
  }

  /**
   * Export a Fedora object with the given PID.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $format
   *   (Optional) The XML format to export. Options: info:fedora/fedora-system:FOXML-1.1 (default),
   *   info:fedora/fedora-system:FOXML-1.0, info:fedora/fedora-system:METSFedoraExt-1.1,
   *   info:fedora/fedora-system:METSFedoraExt-1.0, info:fedora/fedora-system:ATOM-1.1,
   *   info:fedora/fedora-system:ATOMZip-1.1
   * @param String $context
   *   (Optional) The export context, which determines how datastream URLs and content are represented.
   *   Options: public (default), migrate, archive
   * @param String $encoding
   *   (Optional) The preferred encoding of the exported XML.
   * @return StdClass HTTP Response object. The 'data' element contains the requested export data.
   */
  public function export(
    $pid,
    $format = 'info:fedora/fedora-system:FOXML-1.1',
    $context = 'public', $encoding = 'UTF-8'
  ) {
    $pid = drupal_urlencode($pid);
    $format = drupal_urlencode($format);

    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/export?";

    $request .= (!empty($format) ? "format=$format&" : '')
             . (!empty($context) ? "context=$context&" : '')
             . (!empty($encoding) ? "encoding=$encoding" : '');
    $response = drupal_http_request($request);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

 /**
  * Returns the XML metadata information about a datastream.
  *
  * @param String $pid
  *   Persistent identifier of the digital object.
  * @param String $dsID
  *   Datastream identifier.
  * @param String $format
  *   (optional) Default: xml. The preferred output format. Options: xml or html.
  * @param String $asOfDateTime
  *   (optional) Indicates that the result should be relative to the digital object as it existed on the given date.
  *   Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ
  * @param String $validateChecksum
  *   (optional) verifies that the Datastream content has not changed since the checksum was initially computed. If
  *   asOfDateTime is null, Fedora will use the most recent version.
  *
  * @return StdClass HTTP Response object. 'data' has XML set of results.
  * @code
  *   <?xml version="1.0" encoding="UTF-8"?>
  *   <datastreamProfile xmlns="http://www.fedora.info/definitions/1/0/management/"
  *     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  *     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  *     xsi:schemaLocation="http://www.fedora.info/definitions/1/0/management/
  *     http://www.fedora.info/definitions/1/0/datastreamProfile.xsd"
  *     pid="demo:2" dsID="DC">
  *   <dsLabel>Dublin Core Record</dsLabel>
  *   <dsVersionID>DC.0</dsVersionID>
  *   <dsCreateDate>2011-05-05T13:23:58.858Z</dsCreateDate>
  *   <dsState>A</dsState>
  *   <dsMIME>text/xml</dsMIME>
  *   <dsFormatURI/>
  *   <dsControlGroup>X</dsControlGroup>
  *   <dsSize>753</dsSize>
  *   <dsVersionable>true</dsVersionable>
  *   <dsInfoType/>
  *   <dsLocation>demo:2+DC+DC.0</dsLocation>
  *   <dsLocationType/>
  *   <dsChecksumType>DISABLED</dsChecksumType>
  *   <dsChecksum>none</dsChecksum>
  *   </datastreamProfile>
  * @endcode
  */
  public function getDatastream($pid, $dsID, $format = 'xml', $asOfDateTime = NULL, $validateChecksum = FALSE) {
    $pid = drupal_urlencode($pid);
    $fedora_url = $this->connection->requestURL();
    $request = "$fedora_url/objects/$pid/datastreams/$dsID";
    $format = strtolower($format);
    $separator = '?';
    if (in_array($format, array('html', 'xml'))) {
      $request .= "{$separator}format=$format";
      $separator = '&';
    }
    if (!empty($asOfDateTime)) {
      $request .= "{$separator}asOfDateTime=$asOfDateTime";
      $separator = '&';
    }
    if (!empty($validateChecksum)) {
      $request .= "{$separator}validateChecksum=$validateChecksum";
    }
    $response = drupal_http_request($request);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Get a new PID.
   *
   * @param int $numPIDS
   *   (Optional) Default: 1.
   * @param string $namespace
   *   (Optional) Default: ''
   * @param string $format
   *   (Optional) Options: XML (default), HTML
   * @return StdClass HTTP response
   * @code
   * <?xml version="1.0" encoding="UTF-8"?>
   * <pidList  xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   *   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   *   xsi:schemaLocation="http://www.fedora.info/definitions/1/0/management/
   *   http://localhost:8080/getNextPIDInfo.xsd">
   *   <pid>changeme:2</pid>
   * </pidList>
   * @endcode
   *
   * @todo clean up the reqaut code to make it more readable.
   * @todo should we make the namespace default more sensible, something like islandora?
   */
  public function getNextPID($numPIDS = 1, $namespace = '', $format = 'xml') {
    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/nextPID?";
    $request .= (!empty($numPIDS) ? "numPIDS=$numPIDS&" : '')
             . (!empty($namespace) ? "namespace=$namespace&" : '')
             . (!empty($format) ? "format=$format" : '');
    $response = drupal_http_request($request, array(), 'POST');

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Get the fedora objects XML.
   *
   * @param String $pid
   * @return StdClass HTTP response object.
   */
  public function getObjectXML($pid) {
    $pid = drupal_urlencode($pid);
    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/objectXML";
    $response = drupal_http_request($request);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Ingest a FOXML item into Fedora. This could be a string, a file, or a reference to a file that Fedora will
   * go and retreve.
   *
   * @param String $foxml_file
   * @param String $foxml_string
   * @param String $pid
   * @param String $new
   * @param String $label
   * @param String $format
   * @param String $encoding
   * @param String $namespace
   * @param String $ownerId
   * @param String $logMessage
   * @param String $ignoreMime
   * @return StdClass HTTP Response Object
   * $response->data contains just the PID of the ingested object (plain text).
   *
   * @todo See the notes for addDatastream. I think we should revisit how the REST calls are done
   *   on this function.
   */
  public function ingest( $foxml_file = NULL, $foxml_string = NULL, $pid = NULL, $new = TRUE, $label = NULL,
    $format = 'info:fedora/fedora-system:FOXML-1.1', $encoding = 'UTF-8', $namespace = NULL, $ownerId = NULL,
    $logMessage = NULL, $ignoreMime = 'false'
  ) {
    if (empty($pid)) {
      // Set $new to TRUE regardless of what the user specified if no PID is given
      $pid = "new";
    }
    else {
      $pid = drupal_urlencode($pid);
    }
    $label = drupal_urlencode($label);
    $format = drupal_urlencode($format);
    $logMessage = drupal_urlencode($logMessage);
    $params = NULL;
    $headers = array(
      'Keep-Alive' => 115,
      'Connection' => 'keep-alive',
    );
    if (!empty($foxml_file)) {
      // We must construct a multipart HTTP POST.
      $boundary = 'A0sFSD';
      $headers["Content-Type"] = "multipart/form-data; boundary=$boundary";
      $params = FedoraAPIUtils::multipartEncode($boundary, array('foxml_file' => $foxml_file));
    }
    elseif (!empty($foxml_string)) {
      // We must construct a multipart HTTP POST.
      $boundary = 'A0sFSD';
      $headers["Content-Type"] = "multipart/form-data; boundary=$boundary";
      $params = FedoraAPIUtils::multipartEncode($boundary, array('foxml_string' => $foxml_string));
    }

    $fedora_url = $this->connection->requestURL();

    $request = $fedora_url . "/objects/$pid?";

    $request .= (!empty($label) ? "label=$label&" : '')
             . (!empty($format) ? "format=$format&" : '')
             . (!empty($encoding) ? "encoding=$encoding&" : '')
             . (!empty($namespace) ? "namespace=$namespace&" : '')
             . (!empty($ownerId) ? "ownerId=$ownerId&" : '')
             . (!empty($logMessage) ? "logMessage=$logMessage&" : '')
             . (!empty($ignoreMime) ? "ignoreMime=$ignoreMime&" : '');
    $response = drupal_http_request($request, $headers, 'POST', $params);

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;

  }

  /**
   * Modify the parameters of a Fedora datastream.
   *
   * Note: Due to a bug in Fedora you need to specify the Mime Type for each call.
   *
   * @param <type> $pid
   * @param <type> $dsID
   * @param <type> $file_path
   * @param <type> $dsLocation
   * @param <type> $altIDs
   * @param <type> $dsLabel
   * @param <type> $versionable
   * @param <type> $dsState
   * @param <type> $formatURI
   * @param <type> $checksumType
   * @param <type> $checksum
   * @param <type> $mimeType
   * @param <type> $logMessage
   * @param <type> $force
   * @param <type> $ignoreContent
   * @return StdClass HTTP response object
   * @code
   * <?xml version="1.0" encoding="utf-16"?>
   * <datastreamProfile xsi:schemaLocation="http://www.fedora.info/definitions/1/0/management/
   *   http://localhost:8080/datastreamProfile.xsd" pid="islandora:demos" dsID="TN"
   *   xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *     <dsLabel>Thumbnail.png</dsLabel>
   *     <dsVersionID>TN.4</dsVersionID>
   *     <dsCreateDate>2010-04-08T12:27:01.966Z</dsCreateDate>
   *     <dsState>A</dsState>
   *     <dsMIME>image/png</dsMIME>
   *     <dsFormatURI/>
   *     <dsControlGroup>M</dsControlGroup>
   *     <dsSize>0</dsSize>
   *     <dsVersionable>true</dsVersionable>
   *     <dsInfoType/>
   *     <dsLocation>islandora:demos+TN+TN.4</dsLocation>
   *     <dsLocationType>INTERNAL_ID</dsLocationType>
   *     <dsChecksumType>DISABLED</dsChecksumType>
   *     <dsChecksum>none</dsChecksum>
   * </datastreamProfile>
   * @endcode
   *
   * @todo Verify the claim above about mimetypes. Perhaps reference a Fedora issue numebr.
   * @todo Finish the PHPDoc for this function.
   * @todo Cleanup the commented out code specifying the headers.
   */
  public function modifyDatastream( $pid, $dsID, $file_path = NULL, $ds_string = NULL,
    $params = array(
      'dsLocation' => NULL,
      'altIDs' => NULL,
      'dsLabel' => NULL,
      'versionable' => NULL,
      'dsState' => NULL,
      'formatURI' => NULL,
      'checksumType' => NULL,
      'checksum' => NULL,
      'mimeType' => NULL,
      'logMessage' => NULL,
      'force' => NULL,
      'ignoreContent' => NULL
    )
  ) {
    $pid = drupal_urlencode($pid);

    foreach (array('dsLabel', 'formatURI', 'logMessage') as $string_param) {
      if (key_exists($string_param, $params) && $params[$string_param] != NULL) {
        $params[$string_param] = drupal_urlencode($params[$string_param]);
      }
    }

    $request_params = NULL;
    $headers = array(
   //   'Keep-Alive' => 115,
   //   'Connection' => 'keep-alive',
    );

    $fedora_url = $this->connection->requestURL();

    $request = $fedora_url . "/objects/$pid/datastreams/$dsID?";

    foreach ($params as $param_name => $param_value) {
      $request .= $param_value != NULL ? "$param_name=$param_value&" : '';
    }

    $data = (!empty($file_path) ? file_get_contents($file_path) : $ds_string);
    $response = drupal_http_request($request, $headers, 'PUT', $data);

    /*
     * This code block attempts to run the request mulitple times
     * if there is a 'Conflict' response which can indicate that Fedora
     * simply needs more time to finish its last operation on the object.
     *
     * This needs some more thorough testing
     *
     * if this 'Conflict' gets noted during other rest calls this should be
     * turned into a function
     * It has been noted, this needs to be pulled out and all calls to Fedora that
     * change files should got through it.
     * @author
     *   William Panting
     */
    $attempts=0;
    while ($response->code==409 && $attempts<3) {
      $response = drupal_http_request($request, $headers, 'PUT', $data);
      $attempts++;
    }


    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * @todo Please document this function.
   */
  public function modifyObject($pid, $label = NULL, $ownerId = NULL, $state = NULL, $logMessage = NULL) {
    $pid = drupal_urlencode($pid);
    $label = drupal_urlencode($label);
    $logMessage = drupal_urlencode($logMessage);

    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid?";
    $request .= (!empty($label) ? "label=$label&" : '')
             . (!empty($ownerId) ? "ownerId=$ownerId&" : '')
             . (!empty($state) ? "state=$state" : '')
             . (!empty($logMessage) ? "logMessage=$logMessage" : '');
    $response = drupal_http_request($request, array(), 'PUT');
    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Purge a datastream, deleting its contents and all its revisions.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $dsID
   *   Datastream identifier.
   * @param String $startDT
   *   (Optional) Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ - the (inclusive) start date-time stamp of the range.
   *   If not specified, this is taken to be the lowest possible value, and thus, the entire version history up to
   *   the endDT will be purged.
   * @param String $endDT
   *   (Optional) Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ - the (inclusive) ending date-time stamp of the range. If
   *   not specified, this is taken to be the greatest possible value, and thus, the entire version history back to the
   *   startDT will be purged.
   * @param String $logMessage
   *   (Optional) A message describing the activity being performed.
   * @param String $force
   *   (Optional) Options: true, false (default). Force the update even if it would break a data contract.
   * @return StdClass HTTP response object
   *   On Success $response->code will be 204 and $response->error will be 'No content'.
   */
  public function purgeDatastream($pid, $dsID, $startDT = '', $endDT = '', $logMessage = '', $force = 'false') {
    $pid = drupal_urlencode($pid);
    $logMessage = drupal_urlencode($logMessage);
    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/datastreams/$dsID?";
    $request .= (!empty($startDT) ? "startDT=$startDT&" : '')
             . (!empty($endDT) ? "endDT=$endDT&" : '')
             . (!empty($logMessage) ? "logMessage=$logMessage" : '')
             . (!empty($force) ? "force=$force" : '');
    $response = drupal_http_request($request, array(), 'DELETE');

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Purge an object.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $logMessage
   *   (Optional) A message describing the activity being performed.
   * @param String $force
   *   (Optional) Options: true, false (default). Force the update even if it would break a data contract.
   * @return StdClass HTTP Response object
   * $response->code is 204 on successful delete, $response->error is "No content".
   */
  public function purgeObject($pid, $logMessage = '', $force = 'false') {
    $pid = drupal_urlencode($pid);
    $logMessage = drupal_urlencode($logMessage);
    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid?";
    $request .= (!empty($logMessage) ? "logMessage=$logMessage" : '')
             . (!empty($force) ? "force=$force" : '');
    $response = drupal_http_request($request, array(), 'DELETE');

    if (!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * This function will return all the relationships on the object that meet the restrictions specified
   * https://wiki.duraspace.org/display/FCR30/REST+API#RESTAPI-getRelationships
   *
   * @param string $pid
   *   Persistent identifier of the digital object.
   * @param string $predicate
   *  (optional)  If missing all relationships will be returned; this should be the namespace followed by the
   *  predicate, simply concatenated together with no delimination
   * @param string $format
   *   (optional) format of the resonse 	xml (returns rdf/xml), rdf/xml, n-triples, turtle, sparql
   *   defaults as xml
   * @param string $subject
   *   (optional) iether a uri for the boject or one of its datastreams, defaults to the object pid
   *
   * @return StdClass HTTP response object
   */
  public function getRelationships($pid, $predicate = NULL, $subject = NULL, $format = NULL) {
    $pid = drupal_urlencode($pid);

    //druapl url encode should not be used for string arugments
    if (!empty($predicate)) {
      $predicate=urlencode($predicate);
    }
    if (!empty($subject)) {
      $subject=urlencode($subject);
    }
    if (!empty($format)) {
      $format=urlencode($format);
    }

    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/relationships?";
    $request .= (!empty($subject) ? "subject=$subject&" : '')
                         . (!empty($predicate) ? "predicate=$predicate&" : '')
                         . (!empty($format) ? "format=$format" : '');

    $response = drupal_http_request($request, array(), 'GET');

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }
    return $response;
  }

  /**
   * This function will add a single relationship to the object
   * https://wiki.duraspace.org/display/FCR30/REST+API#RESTAPI-addRelationship
   *
   * This function will not overwrite an existing one
   *
   *  @param string $pid
   *    Persistent identifier of the digital object.
   *  @param string $predicate
   *    Predicate of the relationship
   *  @param string $object
   *    object of the relationship
   *  @param array $optional_args
   *  	(optional) This is an associative array of the optional arguments for the rest api the format is:
   *  		string isLiteral
   *    	    (optional) true if the object of the relationship is a literal, false if it is a fedora pid
   *      string subject
   *        (optional) either the URI of the Fedora object's pid or the URI of one of its datastreams, defaults to the Fedora object's URI
   *      string datatype
   *        (optional)  The data type of the RDF object, only supply if the object is a literal
   *  @return StdClass HTTP response object
   *
   *  @todo: refactor to use lower level api elements
   */
  public function addRelationship($pid, $predicate, $object, $optional_args = NULL) {
    //check predicate namespace for the fragment identifier
    if (!FedoraAPIUtils::validateRDFPredicate($predicate)) {
      throw new Exception("There is an issue translating RDF to XML that has Fedora mangling namespaces
    					that do not end in Fragment identifiers when this REST call is made.  One of these was found
            	in the $predicate so the relationship was not added so as to prevent mangling.");
    }
    //constants
    $rdf_namespace = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';

    //figure out which datastream to add the relationship to
    if (isset($optional_args['subject'])) {
      if ($optional_args['subject'] != 'info:fedora/' . $pid) {
        $target_datastream = 'RELS-INT';
      }
    }
    else {
      //set this for use in xml
      $optional_args['subject'] = 'info:fedora/' . $pid;
    }
    if (!isset($target_datastream)) {
      $target_datastream = 'RELS-EXT';
    }

    module_load_include('object.inc', 'islandora_fedora_api');
    $fedora_object = new FedoraObject($pid);
    $object_datastreams = $fedora_object->get_datastreams();
    $relationship_datastream_parser = new DOMDocument();

    //if the datastream is populated
    if (isset($object_datastreams[$target_datastream])) {
      //get the current datastream
      $relationship_datastream_string = $object_datastreams[$target_datastream]->content;
      $relationship_datastream_parser->loadXML($relationship_datastream_string);
      $description_elements = $relationship_datastream_parser->getElementsByTagName('Description');
      $description_node_found = FALSE;

      foreach ($description_elements as $description_element) {
        if ($description_element->hasAttributeNS($rdf_namespace, 'about')) {
          $description_about = $description_element->getAttributeNS($rdf_namespace, 'about');
          //when in the description of the subject
          if ($description_about == $optional_args['subject']) {
            $description_node_found = TRUE;
            $description_node = $description_element;
            break;
          }
        }
      }
      if (!$description_node_found) {//create an "about" node if there isn't one for the subject
        $description_node = $relationship_datastream_parser->createElementNS($rdf_namespace, 'Description');
        $description_node->setAttributeNS($rdf_namespace, 'about', $optional_args['subject']);
        $relationship_datastream_parser_root = $relationship_datastream_parser->documentElement;
        $relationship_datastream_parser_root->appendChild($description_node);
      }
    }
    else {//if the datastream does not exist yet
      //create a RELS datastream
      $relationship_datastream_string = '<rdf:RDF xmlns:rdf="' . $rdf_namespace . '" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:fedora="info:fedora/fedora-system:def/relations-external#" xmlns:fedora-model="info:fedora/fedora-system:def/model#"><rdf:Description rdf:about="'. $optional_args['subject'] .'" > </rdf:Description></rdf:RDF>';
      $relationship_datastream_parser->loadXML($relationship_datastream_string);
      $description_elements = $relationship_datastream_parser->getElementsByTagName('Description');
      $description_node = $description_elements->item(0);
    }
    //create the relationship node and add the object
    $predicate_array = FedoraAPIUtils::explodePredicate($predicate);
    $rdf_xml_relationship_to_write = $relationship_datastream_parser->createElementNS($predicate_array['namespace'], $predicate_array['local_name']);
    if (!isset($optional_args['isLiteral'])) {//set is_literal if not set to FALSE to simplify logic
      $optional_args['isLiteral'] = FALSE;
    }
    if ($optional_args['isLiteral']) {//if the object is a literal then it is added to the element's text
      $relationship_text = $relationship_datastream_parser->createTextNode($object);
      $rdf_xml_relationship_to_write->appendChild($relationship_text);
    }
    else {//if the object is not a literal then it is added to rdf:resource attribute
      $rdf_xml_relationship_to_write->setAttributeNS($rdf_namespace, 'resource', $object);
    }
    //add the new relationship to the datastream
    $description_node->appendChild($rdf_xml_relationship_to_write);

    //upload the updated or new datastream if $new, if $update
    
    if (!isset($object_datastreams[$target_datastream])) {
      $response = $this->addDatastream($pid, $target_datastream, $file_path = NULL,
        $ds_string = $relationship_datastream_parser->saveXML(), $params = array(
          'controlGroup' => 'X',
          'dsLocation' => NULL,
          'altIDs' => NULL,
          'dsLabel' => NULL,
          'dsState' => NULL,
          'formatURI' => NULL,
          'checksumType' => NULL,
          'checksum' => NULL,
          'mimeType' => 'text/xml',
          'logMessage' => 'Datastream created via addRelationship method of islandora_fedora_api',
        ));
    }
    else {
      $response = $this->modifyDatastream($pid, $target_datastream, $file_path = NULL,
        $ds_string = $relationship_datastream_parser->saveXML(), $params = array(
          'dsLocation' => NULL,
          'altIDs' => NULL,
          'dsLabel' => NULL,
          'versionable' => NULL,
          'dsState' => NULL,
          'formatURI' => NULL,
          'checksumType' => NULL,
          'checksum' => NULL,
          'mimeType' => 'text/xml',
          'logMessage' => 'Datastream updated via addRelationship method of islandora_fedora_api',
          'force' => NULL,
          'ignoreContent' => NULL
        ));
    }
    /*
     //this code is for the add relationship REST call that we will not be using because it mangles
    //XML namespaces that do not end in Fragment Identifiers
    //to use this we would have to download and check the datastream for pre-exisiting namespaces
    //that do not have fragment identifiers so to not use it is a performance optimization
    */
    /*
    $pid = drupal_urlencode($pid);
    //drupal url encode should not be used for string arugments
    if (!empty($predicate)) {
        $predicate = urlencode($predicate);
    }
    if (!empty($object)) {
        $object = urlencode($object);
    }
    if (isset($optional_args['subject'])) {
        $optional_args['subject'] = urlencode($optional_args['subject']);
    }

    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/relationships/new?";
    $request .= (isset($optional_args['subject']) ? "subject=" . $optional_args['subject'] . "&" : '')
                         . "predicate=$predicate&"
                         . "object=$object&"
                         . (isset($optional_args['isLiteral']) ? "isLiteral=". $optional_args['isLiteral'] ."&" : '')
                         . (isset($optional_args['datatype']) ? "datatype=". $optional_args['datatype'] : '');

    $response = drupal_http_request($request, array(), 'POST');

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }
    */

    return $response;
  }

 /**
   * This function will purge a single relationship (unless maybe if there is duplication)
   * from an object
   * https://wiki.duraspace.org/display/FCR30/REST+API#RESTAPI-purgeRelationship
   *
   *  @param string $pid
   *    Persistent identifier of the digital object.
   *  @param string $predicate
   *    Predicate of the relationship
   *  @param string $object
   *    object of the relationship
   *  @param array $optional_args
   *  	(optional) This is an associative array of the optional arguments for the rest api the format is:
   *  		string is_literal
   *    	    (optional) true if the object of the relationship is a literal, false if it is a fedora pid
   *      string subject
   *        (optional) either a uri for the boject or one of its datastreams, defaults to the object pid
   *      string datatype
   *        (optional)  The data type of the object, only supply if the object is a literal
   *  @return StdClass HTTP response object
   */
  public function purgeRelationship($pid, $predicate, $object, $optional_args = NULL) {
    //constants
    $rdf_namespace = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';

    //figure out which datastream to add the relationship to
    if (isset($optional_args['subject'])) {
      if ($optional_args['subject'] != 'info:fedora/' . $pid) {
        $target_datastream = 'RELS-INT';
      }
    }
    else {
      //set this for use in xml
      $optional_args['subject'] = 'info:fedora/' . $pid;
    }
    if (!isset($target_datastream)) {
      $target_datastream = 'RELS-EXT';
    }
    if (!isset($optional_args['isLiteral'])) { //set is_literal if not set to FALSE to simplify logic
      $optional_args['isLiteral'] = FALSE;
    }

    module_load_include('object.inc', 'islandora_fedora_api');
    $fedora_object = new FedoraObject($pid);
    $object_datastreams = $fedora_object->get_datastreams();
    $relationship_datastream_parser = new DOMDocument();
    
    $target_datastream_string = $object_datastreams[$target_datastream]->content;
    
    $relationship_datastream_parser->loadXML($target_datastream_string);
    $predicate_array = FedoraAPIUtils::explodePredicate($predicate);
    #get all the elements with the predicate
    $possible_elements = $relationship_datastream_parser->getElementsByTagNameNS($predicate_array['namespace'], $predicate_array['local_name']);
    
    #filter by subject and object
    foreach ($possible_elements as $possible_element) {
      #the subject is in the parent element 'descrition'
      $description_about = $possible_element->parentNode->getAttributeNS($rdf_namespace, 'about');
      //when in the description of the subject
      if ($description_about == $optional_args['subject']) {
       //checkout the object of the relationship
        if ($optional_args['isLiteral']) {//if the object is a literal then it is added to the element's text
         //check the text for the object
         if($possible_element->nodeValue == $object) {
          $possible_element->parentNode->removeChild($possible_element);//removes the node it's the target
         }
        }
        else {
         //check rdf:resource
         if($possible_element->getAttributeNS($rdf_namespace, 'resource') == $object) {
          $possible_element->parentNode->removeChild($possible_element);//removes the node it's the target
         }
        }
      }
    }
    
    /*
    $pid = drupal_urlencode($pid);
      //druapl url encode should not be used for string arugments
    if (!empty($predicate)) {
      $predicate=urlencode($predicate);
    }
    if (!empty($object)) {
      $object=urlencode($object);
    }
    if (isset($optional_args['subject'])) {
      $optional_args['subject']=urlencode($optional_args['subject']);
    }

    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/relationships?";
    $request .= (isset($optional_args['subject']) ? "subject=" . $optional_args['subject'] . "&" : '')
                         . "predicate=$predicate&"
                         . "object=$object&"
                         . (isset($optional_args['isLiteral']) ? "isLiteral=". $optional_args['isLiteral'] ."&" : '')
                         . (isset($optional_args['datatype']) ? "datatype=". $optional_args['datatype'] : '');
    $response = drupal_http_request($request, array(), 'DELETE');

    if (!FedoraAPIUtils::testSuccess($response)) {
      module_load_include('exception.inc', 'islandora_fedora_api');
      throw new FedoraApiRestException($response);
    }
    */
    $response = $this->modifyDatastream($pid, $target_datastream, $file_path = NULL,
      $ds_string = $relationship_datastream_parser->saveXML(), $params = array(
        'dsLocation' => NULL,
        'altIDs' => NULL,
        'dsLabel' => NULL,
        'versionable' => NULL,
        'dsState' => NULL,
        'formatURI' => NULL,
        'checksumType' => NULL,
        'checksum' => NULL,
        'mimeType' => 'text/xml',
        'logMessage' => 'Datastream updated via addRelationship method of islandora_fedora_api',
        'force' => NULL,
        'ignoreContent' => NULL
      ));

    return $response;
  }
}


/**
 * A collection of helpful utilities for dealing with fedora.
 *
 * @todo Should this be refactored out into its own file?
 */
class FedoraAPIUtils {

  /**
   * This function will check an RDF predicate for correctness.  This currently
   * means that it will make sure that the namespace is sepearated from the idiom
   * by a Fragment Identifier.  This is to insure that inapropriate xml namespaces
   * are not used for RDF.  This functionality can be expanded in the future as needed.
   * @param $predicate
   *   The predicate to check for correctness
   * @return bool
   *   True if the predicate passes testing
   *   False if the predicate does not pass testing
   */
  public static function validateRDFPredicate($predicate) {
     //if a # comes after the last / we are good
     $hash_position = strrpos($predicate, '#');
     $slash_position = strrpos($predicate, '/');
     return $hash_position && $slash_position && !($slash_position > $hash_position);
  }

  /**
   * This funciton will take an RDF predicate and turn it into an XML
   * namespace and local name.
   *
   * @param string $predicate
   *   The RDF predicate to transform
	 * @return array $predicate_array
	 *   An associative array conataining
	 *   ('namespace'=>'','local_name'=>'')
   */
  public static function explodePredicate($predicate) {
    $tmp_predicate_array = explode('#', $predicate);
    $predicate_array = array('namespace' => $tmp_predicate_array[0] . '#',
      'local_name' => $tmp_predicate_array[1]);
    return $predicate_array;
  }

  /**
   * This function will check the offending object's RELS-INT or RELS-EXT for
   * non-deliminated namespaces.  This is necessary because Fedora will mangle
   * namespaces and element names for entries that do not have their namespaces
   * end in Fragment Identifiers.
   * @note
   * 	 This function is not used in the API but we should leave it in so that
   *   if someone needs to repair some broken namespaces they will not need to
   *	 recreate this function.
   * @param $object_id
   *   The fedora pid of the object to check
   * @param $dsid
   *   The fedora datastrem id fo the object to check
   * @return bool
   *   True if there are no broken namespaces
   *   False if there are broken namespaces or if an improper DSID is set
   */
  public static function validateRDFNamespacesInRELS($object_id, $datastream_id) {
    if ($datastream_id != 'RELS-EXT' && $datastream_id != 'RELS-INT') {
      return FALSE;
    }
    module_load_include('object.inc', 'islandora_fedora_api');

    $object = new FedoraObject($object_id);

    $object_datastreams = $object->get_datastreams();

    //proceed if the datastream exists
    if (isset($object_datastreams[$datastream_id])) {
      $relationship_datastream_string = $object_datastreams[$datastream_id]->content;
      $relationship_datastream_parser = new SimpleXMLElement($relationship_datastream_string);
      $relationship_datastream_namespaces = $relationship_datastream_parser->getNamespaces(true);
      //iterate through namespaces and return false if one does not end in the Fragment Identifier
      foreach ($relationship_datastream_namespaces as $relationship_namespace) {
        $relationship_string_length = strlen($relationship_namespace);
        if (substr($relationship_namespace, $relationship_string_length-1, 1) != '#') {
          return FALSE;
        }
      }
    }
    //if a non-daliminated datastream was not found return true
    return TRUE;
  }

  /**
   * Tests if the given PID fits the general rules for a PID. Must start with a letter, must be less the 64 characters,
   * no special characters, etc. This says nothing about the PID existing, it just tests the string with a regular
   * expression.
   *
   * @param String $pid
   *
   * @return boolean
   *
   * @todo Document where this regex came from. I believe it is in the Fedora documentation somewhere.
   */
  static function validPid($pid) {
    $valid = FALSE;
    if (strlen(trim($pid)) <= 64 && preg_match('/^([A-Za-z0-9]|-|\.)+:(([A-Za-z0-9])|-|\.|~|_|(%[0-9A-F]{2}))+$/', trim($pid))) {
      $valid = TRUE;
    }

    return $valid;
  }

  /**
   * Tests if the given DSID is valid. As above, this function is just a regular expression to validate the DSID, it
   * says nothing about the DSID actually existing.
   *
   * @param string $dsid
   *
   * @return boolean
   *
   * @todo As above we should document where this regex came from. I know I have seen it in the Fedora documenation
   *   somewhere before.
   */
  static function validDsid($dsid) {
    $valid = FALSE;
    if (strlen(trim($dsid)) <= 64 && preg_match('/^[a-zA-Z0-9\_\-\.]+$/', trim($dsid))) {
      $valid = TRUE;
    }

    return $valid;
  }

  /**
   * This function takes a string, and returns a string that is a valid DSID. This is very useful if using filenames
   * as DSIDs as most operating systems file names are less restrictive then DSIDs. This matches the Python
   * implementation of this function.
   * The algorithm is:
   * 1) It removes all characters that are unsupported in a DSID.
   * 2) If the string is too long, it takes the last 64 characters of the string.
   * 3) If the string starts with a number, prepend random letter.
   * 4) If string is empty, make is a random 10 character string.
   *
   * @param String $dsid
   * @return String
   *   The mangled DSID.
   */
  static function mangleDsid($dsid) {
    $new_dsid = trim($dsid);

    $string_array = 'abcdefghijklmnopqustuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

    $find = '/[^a-zA-Z0-9\.\_\-]/';
    $replace = '';
    $new_dsid = preg_replace($find, $replace, $new_dsid);

    if ( strlen($new_dsid) > 64 ) {
      $new_dsid = substr($new_dsid, -64);
    }

    if ( preg_match('/^[^a-zA-Z]/', $dsid )) {
      if ( strlen($new_dsid) == 64 ) {
        $new_dsid = substr($new_dsid, -63);
      }
      $new_dsid = this::randomString() . $new_dsid;
    }

    if ( strlen($new_dsid) == 0 )
      $new_dsid = this::randomString(10);

    return $new_dsid;
  }

  // This is defined for the function above
  private static function randomString($length = 1) {
    $array = 'abcdefghijklmnopqustuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

    $string = '';

    while ( $length > 0 ) {
      $string .= $array[rand(0, 51)];
      $length--;
    }

    return $string;
  }


  /**
   * Returns TRUE if the http response code in the supplied $http_response is a 2XX success code.
   *
   * @todo make sure this is correct
   * @todo should we be logging here
   * @param StdObject $http_response
   */
  static function testSuccess($http_response, $log = FALSE, $request = '') {
    $code = (string) $http_response->code;

    if ( $code[0] == '2' ) {
      return TRUE;
    }
    else {
      if ( $log == TRUE ) {
        this::logError($http_response, $request);
      }
      return FALSE;
    }
  }

  static function logError($http_response, $request) {
    watchdog('fedora api', 'Error executing Fedora REST request %request: %error',
      array('%request' => $request, '%error' => $http_response->error), WATCHDOG_ERROR
    );
  }

  static function multipartEncode($boundary, $params) {
    if (empty($params)) {
      return NULL;
    }

    $output = "";
    foreach ($params as $key => $value) {
      $output .= "--$boundary\r\n";
      if ($key == 'file') {
        $output .= this::multipartEncodeFile($value);
      }
      elseif ($key == 'foxml_file') {
        $output .= this::multipartEncodeXMLFile($value);
      }
      elseif ($key == 'foxml_string') {
        $output .= this::multipartEncodeXMLString($value);
      }
      else {
        $output .= this::multipartEncodeText($key, $value);
      }
    }
    $output .= "--$boundary--";
    return $output;
  }

  protected static function multipartEncodeFile($path) {
    // remove @ at beginning
    if (substr($path, 0, 1) == "@") {
      $path = substr($path, 1);
    }
    $filename = basename($path);
    $mimetype = "application/octet-stream";
    $data = "Content-Disposition: form-data; name=\"file\"; filename=\"$filename\"\r\n";
    $data .= "Content-Transfer-Encoding: binary\r\n";
    $data .= "Content-Type: $mimetype\r\n\r\n";
    $data .= file_get_contents($path) . "\r\n";
    return $data;
  }

  protected static function multipartEncodeXMLFile($path) {
    if (substr($path, 0, 1) == "@") {
      $path = substr($path, 1);
    }
    $filename = basename($path);
    $mimetype = "text/xml";
    $data = "Content-Disposition: form-data; name=\"file\"; filename=\"$filename\"\r\n";
    $data .= "Content-Transfer-Encoding: UTF-8\r\n";
    $data .= "Content-Type: $mimetype\r\n\r\n";
    $data .= file_get_contents($path) . "\r\n";
    return $data;
  }

  protected static function multipartEncodeXMLString($xml_data) {
    $mimetype = "text/xml";
    $data = "Content-Disposition: form-data; name=\"foxml\"; filename=\"FOXML\"\r\n";
    $data .= "Content-Transfer-Encoding: UTF-8\r\n";
    $data .= "Content-Type: $mimetype\r\n\r\n";
    $data .= $xml_data . "\r\n";
    return $data;
  }

  protected static function multipartEncodeText($name, $value) {
    $mimeType = 'text/plain';
    $data = "Content-Disposition: form-data: name=\"$name\" filename=\"$name\"\r\n";
    $data .= "Content-Transfer-Encoding: UTF-8\r\n";
    $data .= "Content-Type: $mimeType\r\n\r\n";
    $data .= "$value\r\n";
    return $data;
    return "Content-Disposition: form-data; name=\"$name\"\r\n\r\n$value\r\n";
  }

}
